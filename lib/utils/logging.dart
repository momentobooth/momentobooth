import 'package:momento_booth/main.dart';
import 'package:stack_trace/stack_trace.dart';
import 'package:talker_flutter/talker_flutter.dart' as talker;

/// Log something that (could) crash(ed) the application (e.g. helper library panic).
void logFatal(String message) => logMessage(LogLevel.fatal, message);

/// Logs a critical error that prevents or severely disrupts normal application flow
/// (e.g., printing failed, image capture failed).
void logError(String message) => logMessage(LogLevel.error, message);

/// Logs a warning about a situation that could affect correct or expected behavior,
/// but does not immediately break application flow.
void logWarning(String message) => logMessage(LogLevel.warning, message);

/// Logs noteworthy information about application events or state that may be
/// useful for understanding behavior, but occurs infrequently (e.g., every few minutes).
void logInfo(String message) => logMessage(LogLevel.info, message);

/// Logs detailed diagnostic information useful during development or debugging.
/// Typically disabled in production environments.
void logDebug(String message) => logMessage(LogLevel.debug, message);

/// Logs fine-grained execution details, such as function entry/exit points
/// or intermediate state, to help trace program flow step-by-step.
void logTrace(String message) => logMessage(LogLevel.trace, message);

// /////// //
// Helpers //
// /////// //

/// Translate and route the log message to upstream log systems.
void logMessage(LogLevel level, String message, {LogSource source = LogSource.dart}) {
  // Try to determine caller member name and class.
  String? className, memberName;
  String? callingMember = Trace.current(2).frames[0].member;
  if (callingMember != null) {
    callingMember = callingMember.replaceAll('.<fn>', ''); // Remove callbacks.
    List<String> memberPath = callingMember.split('.');

    if (memberPath.length == 1) {
      memberName = memberPath[0];
    } else if (memberPath.length > 1) {
      className = memberPath[0];
      memberName = memberPath.skip(1).join('.');
    }
  }

  String talkerMessage = '';
  if (className != null) talkerMessage += '[$className] ';
  if (memberName != null) talkerMessage += '[$memberName] ';
  getIt<talker.Talker>().log(
    talkerMessage + message,
    logLevel: switch (level) {
      LogLevel.fatal => talker.LogLevel.critical,
      LogLevel.error => talker.LogLevel.error,
      LogLevel.warning => talker.LogLevel.warning,
      LogLevel.info => talker.LogLevel.info,
      LogLevel.debug => talker.LogLevel.debug,
      LogLevel.trace => talker.LogLevel.verbose,
    },
  );
}

// ////// //
// Models //
// ////// //

/// Defines the severity or verbosity of log messages.
enum LogLevel {
  /// Critical error that causes the application to crash or stop functioning.
  /// Must be addressed immediately (e.g., unrecoverable failure).
  fatal,

  /// Error that disrupts normal application behavior,
  /// but does not necessarily terminate the application.
  error,

  /// Potential issue that may affect expected behavior,
  /// but does not prevent the application from continuing.
  warning,

  /// General information about application events or state
  /// that may be useful for monitoring and understanding flow.
  info,

  /// Detailed diagnostic messages useful during development
  /// to track state changes, values, or decision points.
  debug,

  /// Very fine-grained logs that trace execution flow step-by-step
  /// (e.g., function entry/exit, intermediate states).
  trace,
}

/// Identifies the origin of a log message within the application.
enum LogSource {
  /// The log message was generated by the Flutter/Dart side of the application.
  dart,

  /// The log message was generated by the Rust helper library.
  rust,
}
